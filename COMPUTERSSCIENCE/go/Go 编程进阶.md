# Go 编程进阶







## 常见数据结构的实现原理





### 1. 管道

* 内置函数`len()`和`cap()`作用于管道，分别用于查询缓冲区中数据的个数及缓冲区大小
* 管道实现了一种**FIFO**（先入先出）的队列，数据总是按照写入的顺序流出管道
* 协程读取管道时，阻塞的条件有：
  * 管道无缓冲区
  * 管道的缓冲区中无数据
  * 管道的值为**nil**
* 协程写入管道时，阻塞的条件有：
  * 管道无缓冲区
  * 管道的缓冲区已满
  * 管道的值为**nil**



#### 实现原理



###### 数据结构

在源码包中`src/runtime/chan.go:hchan`定义了管道的数据结构

```go
type hchan struct {
    qcount		uint			// 当前队列中剩余的元素个数
    dataqsiz	uint			// 环形队列长度，即可以存放的元素个数
    buf			unsafe.Pointer	// 环形队列指针
    elemsize	uint16			// 每个元素的大小
    closed		uint32			// 标识关闭状态
    elemtype	*_type			// 元素类型
    sendx		uint			// 队列下标，指示元素写入时存放到队列的位置
    recvx		uint			// 队列下标，指示下一个被读取的元素在队列中的位置
    recvq		waitq			// 等待读消息的协程队列
    sendq		waitq			// 等待写消息的协程队列
    lock		mutex			// 互斥锁，chan不允许并发读写
}
```

* **环形队列**

`chan`内部实现了一个环形队列作为其缓冲区，队列的长度是在创建`chan`时指定的。使用数组实现队列是比较常见的操作，`sendx`和`recvx`分别表示队尾和队首，`sendx`指示数据写入的位置，`recvx`指示数据读取的位置

* **等待队列**

从管道读取数据时，若管道缓冲去为空或没有缓冲区，则当前协程会被阻塞，并加入`recvq`队列。向管道写入数据时，如果管道缓冲去已满或没有缓冲去，则当前协程会被阻塞，并被加入`sendq`队列

处于等待队列中的协程会在其他协程操作管道时被唤醒：

* 因读阻塞的协程会被向管道写入数据的协程唤醒
* 因写阻塞的协程会被从管道读取数据的协程唤醒

***一般情况下， recvq 和 sendq 至少有一个为空。只有一个例外，那就是同一个协程使用 select 语句向管道一边写入数据，一边读取数据，此时协程会分别位于两个等待队列中***

* **类型信息**

一个管道只能传递一种类型的值，类型信息存储在hchan数据结构中

* `elemtype`代表类型，用于在数据传递过程中赋值
* `elemsize`代表类型大小，用于在`buf`中定位元素的位置

***如果需要管道传递任意类型的数据，则可以使用`interface()`类型***

* **互斥锁**

一个管道同时仅允许被一个协程读写



###### 管道操作

1. 创建管道

创建管道的过程实际上是初始化`hchan`结构，其中类型信息和缓冲区长度由内置函数`make()`指定，`buf`的大小则由元素大小和缓冲区长度共同决定

伪代码如下

```go
func makechan(t *chantype, size int) *hchan {
    var c *hchan
    c = new(hchan)
    c.buf = malloc(元素类型大小 * size)
    c.elemsize = 元素类型大小
    c.eletype = 元素类型
    c.dataqsiz = size
    
    return c
}
```



