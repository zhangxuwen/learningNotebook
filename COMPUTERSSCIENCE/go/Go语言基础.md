# Go语言基础







## 入门



### `go run filename.go`

可以将一个或者多个以.go为后缀的源文件进行编译、链接，然后运行生成的可执行文件。



### `go build filename.go`

一般用于不是一次性的实验，编译输出成一个可复用的程序。



### `:=`

用于```短变量声明```，这个宏语句声明一个或多个变量，并且更具初始化的值给予合适的类型



### `i++`

等价于`i += 1`，又等价于`i = i + 1`，对应的递减语句`i--`同理。这些是语句，不同于`C`族语句一样是表达式，`j = i++`是不合法的，并且只支持后缀。



### `for`

`Go`里面唯一的循环语句



`_`

空标识符，可以用在任何语法需要变量名但是程序逻辑不需要的地方







## 程序结构



### 名称

* 名称的开头是一个字母或下划线、后面可以跟任意数量的字符、数字和下划线并区分大小写。
* 风格上采用“驼峰式”。

#### 25个关键字

```go
break：退出循环

default：选择结构默认项（switch、select）

func：定义函数

interface：定义接口

select：channel

case：选择结构标签

chan：定义 channel

const：常量

continue：跳过本次循环

defer：延迟执行内容（收尾工作）

go：并发执行

map：map 类型

struct：定义结构体

else：选择结构

goto：跳转语句

package：包

switch：选择结构

fallthrough：流程控制

if：选择结构

range：从 slice、map 等结构中取元素

type：定义类型

for：循环

import：导入包

return：返回

var：定义变量
```

#### 预声明常量、类型和函数

```go
常量：true    false    iota    nil

类型：int       int8      int16     int32     int64

           uint     uint8    uint16   uint32   uint64    uintptr

           float32   float64    complex128      complex64

           bool     byte     rune      string    error

函数： make    len    cap    new    append    copy    close    delete   

            complex     real    imag

            panic      recover
```



### 声明

4个主要的声明：变量(`var`)，常量(`const`)，类型(`type`)和函数(`func`)。



### 变量

`var`声明创建一个具体类型的变量。每一个声明都有一个通用的形式：

 <center> var name type = expression </center>

类型和表达式部分可以省略一个，但是不能都省略，Go里面不存在未初始化变量。

可以声明一个变量列表，忽略类型允许声明多个不同类型的变量，如：

```go
var i, j, k int		//int, int, int
var b, f, s = true, 2.3, "four"		//bool, float64, string
```

#### 短变量声明

一种称作`短变量声明`的可选形式可以用来声明和初始化局部变量。它使用`name := expression`的形式，`name`的类型由`expression`的类型决定。

* 短变量声明不需要声明所有在左边的变量

在如下代码中，第一条语句声明了`in`和`err`。第二条语句仅声明了`out`，但向已有的`err`变量赋了值。

```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

* 短变量声明最少声明一个变量，否则，代码编译将无法通过。

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // 编译错误：没有新的变量
```

#### 指针

指针的值是一个变量的地址。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

```go
x := 1
p := &x				// p 是整型指针，指向 x 
fmt.Println(*p)		// "1"
*p = 2				// 等于 x = 2
fmt.Println(x)		// 结果 "2"
```

* 指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是`nil`的情况才相等。

```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```

* 函数返回局部变量的地址是非常安全的。

例如，通过下面代码，调用函数f产生局部变量v即使在调用返回后依然存在，指针p依然引用它：

```go
var p = f()
func f() *int {
    v := 1
    return &v
}
```

每次调用f都会返回一个不同的值：

```go
fmt.Println(f() == f()) // "false"
```

#### new函数

使用内置的`new`函数也是创建变量的一种方式。表达式`new(T)`创建一个未命名的`T`类型变量，初始化为`T`类型的零值，并返回其地址（地址类型为`*T`）。

```go
func newInt() *int {
    return new(int)
}
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

* `new`是一个预声明的函数，不是一个关键字，所以他可以重定义为另外的其他类型。

####  变量的生命周期

生命周期指在程序执行过程中变量存在的时间段。变量的生命周期是通过它是否可达来确定。

* 局部变量可在包含它的循环的一次迭代中之外继续存活，即使包含它的循环已经返回，它的存在还可能延续。

**C++如果使用new操作申请的内存是分配在堆上的要自己利用delete进行回收，如果是声明的局部变量会在栈上分配内存，并且在函数退出后由系统自动回收。但是Golang在这方面与传统语言发生了非常大的区别，go语言编译器会做逃逸分析（escape analysis），分析局部变量的作用域是否逃出函数的作用域，要是没有，那么就放在栈上；要是变量的作用域超出了函数的作用域，那么就自动放在堆上。所以不用担心会不会memory leak，因为go语言有强大的垃圾回收机制。这样可以释放程序员的内存使用限制，让程序员关注程序逻辑本身。go语言也允许利用new来分配内存，但是new分配的内存也不是一定就放在堆上，而是根据其是否超出了函数作用域来判断是否放在堆上还是栈上。这点和C/C++很不一样。**

### 赋值

赋值语句用来更新变量所指的值，它最简单的形式由赋值符`=`，以及符号左边的变量和右边的表达式组成。

#### 多重赋值

在实际更新变量前，右边所有表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用。

* 交换两个变量

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

* 使一个普通的赋值序列变得紧凑

```go
i, j, k = 2, 3, 5
```

#### 可赋值性

可赋值性根据类型不同有着不同的规则，类型必须精确匹配，`nil`可以被赋给任何接口变量或引用类型。

### 类型声明

`type`声明定义一个新的命名类型，它和某个已有类型使用相同的`底层类型`。

* 命名类型提供了一种方式来区分底层类型的不同或者不兼容使用，这样它们就不会在无意中混用。







## 基本数据

计算机底层全是位，而实际操作则是基于大小固定的单元中的数值，称为字（word）。

* Golang的二元操作符按优先级的降序排列如下。

```go
*	/	%	<<	>>	&	&^
+	-	|	^	
==	!=	<	>	>=	
&&	
||
```





### 整数

有符号整数分四种大小：8位、16位、32位、64位，用`int8`，`int16`，`int32`，`int64`表示，对应的无符号整数是`uint8`，`uint16`，`uint32`，`uint64`。此外还有`int`和`uint`。

* `rune`类型是`int32`类型的同义词，常常用于指明一个值是`Unicode`码点。同样，`byte`类型是`uint8`类型的同义词，强调一个值是原始数据，而非量值。
* 无符号整数`uintptr`其大小并不明确，但足以完整存放指针。
