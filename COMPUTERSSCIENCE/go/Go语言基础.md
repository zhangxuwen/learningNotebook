# Go语言基础







## 入门



### `go run filename.go`

可以将一个或者多个以.go为后缀的源文件进行编译、链接，然后运行生成的可执行文件。



### `go build filename.go`

一般用于不是一次性的实验，编译输出成一个可复用的程序。



### `:=`

用于```短变量声明```，这个宏语句声明一个或多个变量，并且更具初始化的值给予合适的类型



### `i++`

等价于`i += 1`，又等价于`i = i + 1`，对应的递减语句`i--`同理。这些是语句，不同于`C`族语句一样是表达式，`j = i++`是不合法的，并且只支持后缀。



### `for`

`Go`里面唯一的循环语句



`_`

空标识符，可以用在任何语法需要变量名但是程序逻辑不需要的地方







## 程序结构



### 名称

* 名称的开头是一个字母或下划线、后面可以跟任意数量的字符、数字和下划线并区分大小写。
* 风格上采用“驼峰式”。

#### 25个关键字

```go
break：退出循环

default：选择结构默认项（switch、select）

func：定义函数

interface：定义接口

select：channel

case：选择结构标签

chan：定义 channel

const：常量

continue：跳过本次循环

defer：延迟执行内容（收尾工作）

go：并发执行

map：map 类型

struct：定义结构体

else：选择结构

goto：跳转语句

package：包

switch：选择结构

fallthrough：流程控制

if：选择结构

range：从 slice、map 等结构中取元素

type：定义类型

for：循环

import：导入包

return：返回

var：定义变量
```

#### 预声明常量、类型和函数

```go
常量：true    false    iota    nil

类型：int       int8      int16     int32     int64

           uint     uint8    uint16   uint32   uint64    uintptr

           float32   float64    complex128      complex64

           bool     byte     rune      string    error

函数： make    len    cap    new    append    copy    close    delete   

            complex     real    imag

            panic      recover
```



### 声明

4个主要的声明：变量(`var`)，常量(`const`)，类型(`type`)和函数(`func`)。



### 变量

`var`声明创建一个具体类型的变量。每一个声明都有一个通用的形式：

 <center> var name type = expression </center>

类型和表达式部分可以省略一个，但是不能都省略，Go里面不存在未初始化变量。

可以声明一个变量列表，忽略类型允许声明多个不同类型的变量，如：

```go
var i, j, k int		//int, int, int
var b, f, s = true, 2.3, "four"		//bool, float64, string
```

#### 短变量声明

一种称作`短变量声明`的可选形式可以用来声明和初始化局部变量。它使用`name := expression`的形式，`name`的类型由`expression`的类型决定。

* 短变量声明不需要声明所有在左边的变量

在如下代码中，第一条语句声明了`in`和`err`。第二条语句仅声明了`out`，但向已有的`err`变量赋了值。

```go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

* 短变量声明最少声明一个变量，否则，代码编译将无法通过。

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // 编译错误：没有新的变量
```

#### 指针

指针的值是一个变量的地址。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

```go
x := 1
p := &x				// p 是整型指针，指向 x 
fmt.Println(*p)		// "1"
*p = 2				// 等于 x = 2
fmt.Println(x)		// 结果 "2"
```

* 指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是`nil`的情况才相等。

```go
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```

* 函数返回局部变量的地址是非常安全的。

例如，通过下面代码，调用函数f产生局部变量v即使在调用返回后依然存在，指针p依然引用它：

```go
var p = f()
func f() *int {
    v := 1
    return &v
}
```

每次调用f都会返回一个不同的值：

```go
fmt.Println(f() == f()) // "false"
```

#### new函数

使用内置的`new`函数也是创建变量的一种方式。表达式`new(T)`创建一个未命名的`T`类型变量，初始化为`T`类型的零值，并返回其地址（地址类型为`*T`）。

```go
func newInt() *int {
    return new(int)
}
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

* `new`是一个预声明的函数，不是一个关键字，所以他可以重定义为另外的其他类型。

####  变量的生命周期

生命周期指在程序执行过程中变量存在的时间段。变量的生命周期是通过它是否可达来确定。

* 局部变量可在包含它的循环的一次迭代中之外继续存活，即使包含它的循环已经返回，它的存在还可能延续。

**C++如果使用new操作申请的内存是分配在堆上的要自己利用delete进行回收，如果是声明的局部变量会在栈上分配内存，并且在函数退出后由系统自动回收。但是Golang在这方面与传统语言发生了非常大的区别，go语言编译器会做逃逸分析（escape analysis），分析局部变量的作用域是否逃出函数的作用域，要是没有，那么就放在栈上；要是变量的作用域超出了函数的作用域，那么就自动放在堆上。所以不用担心会不会memory leak，因为go语言有强大的垃圾回收机制。这样可以释放程序员的内存使用限制，让程序员关注程序逻辑本身。go语言也允许利用new来分配内存，但是new分配的内存也不是一定就放在堆上，而是根据其是否超出了函数作用域来判断是否放在堆上还是栈上。这点和C/C++很不一样。**

### 赋值

赋值语句用来更新变量所指的值，它最简单的形式由赋值符`=`，以及符号左边的变量和右边的表达式组成。

#### 多重赋值

在实际更新变量前，右边所有表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用。

* 交换两个变量

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

* 使一个普通的赋值序列变得紧凑

```go
i, j, k = 2, 3, 5
```

#### 可赋值性

可赋值性根据类型不同有着不同的规则，类型必须精确匹配，`nil`可以被赋给任何接口变量或引用类型。

### 类型声明

`type`声明定义一个新的命名类型，它和某个已有类型使用相同的`底层类型`。

* 命名类型提供了一种方式来区分底层类型的不同或者不兼容使用，这样它们就不会在无意中混用。







## 基本数据

计算机底层全是位，而实际操作则是基于大小固定的单元中的数值，称为字（word）。

* Golang的二元操作符按优先级的降序排列如下。

```go
*	/	%	<<	>>	&	&^(AND NOT)
+	-	|	^	
==	!=	<	>	>=	
&&	
||
```

 

### 整数

有符号整数分四种大小：8位、16位、32位、64位，用`int8`，`int16`，`int32`，`int64`表示，对应的无符号整数是`uint8`，`uint16`，`uint32`，`uint64`。此外还有`int`和`uint`。

* `rune`类型是`int32`类型的同义词，常常用于指明一个值是`Unicode`码点。同样，`byte`类型是`uint8`类型的同义词，强调一个值是原始数据，而非量值。
* 无符号整数`uintptr`其大小并不明确，但足以完整存放指针。

* 若表示算术运算结果所需的位超出该类型的范围，就称为`溢出`。
* 比较表达式本身类型是布尔型。

* 如果将整数以位模式处理，须使用无符号整型。

* 无符号整数往往只用于位运算和特定算术运算符，如实现位集时，解析二进制格式的文件，或散列和加密。一般而言，无符号整数极少用于表示非负值。

##### fmt小技巧

* 通常```Printf```的格式化字符串含有多个`%`谓词，这要求提供相同数目的操作数，而`%`后的副词`[1]`告知```Printf```重复使用第一个操作数。
* `%o`，`%x`，或`%X`之前的副词`#`告知```Printf```输出相应的前缀`0`、`0x`、`0X`。
* ```Printf```用谓词`%b`以二进制形式输出数值，副词`08`能在这个输出结果前补0，补够8位。
* 用`%c`输出文字符号，如果希望输出带有单引号则用`%q`。



### 浮点数

Go具有两种大小的浮点数`float32`和`float64`。常量`math.MaxFloat32`是`float32`的最大值，大约为`3.4e38`，而`math.MaxFloat64`则大约为`1.8e308`。相应地，最小的正浮点值大约位`1.4e-45`和`4.9e-324`。

##### fmt小技巧

* `%g`会自动保持足够的精度，并选择最简洁的表达方式，但是对于数据表，`%e`（有指数）或`%f`（无指数）的形式可能更合适。



### 复数

Go具备两种大小的复数`complex64`和`complex128`，二者分别由`float32`和`float64`构成。内置的`complex`函数根据给定的实部和虚部创建复数，而内置的`real`函数和`imag`函数则分别提取

* 源码中，如果在浮点数或十进制整数后面紧接着写字母`i`，如`3.1415926i`或`2i`，它就变成了一个虚数，表示一个实部为0的复数。



### 布尔值

`bool`型的值或布尔值（`boolean`）只有两种可能：真（`true`）和假（`false`）。



### 字符串

字符串是不可变的字节序列，它可以包含任意数据，包括0值字节，但主要是人类可读的文本。

* 不可变一位置两个字符串能安全地共用同一段底层内存，使得复制任何长度字符串的开销都低廉。

#### 字符串字面量

`Go`的源文件总是按`UTF-8`编码，并且习惯上`Go`的字符串会按`UTF-8`解读。

* 原生的字符串字面量的书写形式是\`...\`，使用反引号而不是双引号。

#### Unicode

文字符号的序列表示成`int32`值序列，这种表示方式称作`UTF-32`或`UCS-4`，每个`Unicode`码点的编码长度相同，都是`32`位。

#### UTF-8

```import "unicode/utf8"```

`UTF-8`以字节为单位对`Unicode`码点做变长编码。

* 若最高位为`0`，则标示着它是`7`为的`ASCII`码，其文字符号的编码仅占`1`字节；若最高几位是`110`，则文字符号的编码占用`2`个字节，第二个字节以`10`开始。更长的编码以此类推。

#### 字符串和字节slice

4个标准包对字符串操作特别重要：`bytes`，`strings`，`strconv`和`unicode`。

* 字符串包含一个字节数组，创建后它就无法改变。相反地，字节`slice`的元素允许随意修改。

`strings`包具备下面6个函数：

```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```

`bytes`包里面的对应函数为：

```go
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte
```

`bytes`包为高效处理字节`slice`提供了`Buffer`类型。`bytes.Buffer`类型无须初始化，原因是零值本来就有效。

* 若要在`bytes.Buffer`变量后面添加任意文字符号的`UTF-8`编码，最好使用`bytes.Buffer`的`WriteRune`方法，而追加`ASCII`字符，则使用`WriteByte`亦可。

#### 字符串和数字的相互转换

* 要将整数转换成字符串，一种选择是使用`fmt.Sprintf`，另一种做法是用函数`strconv.Itoa("integer to ASCII")`。
* `strconv`包内的`Atoi`函数或`ParseInt`函数用于解释表示整数的字符串，而`ParseUint`用于无符号整数。

```go
x, err := strconv.Atoi("123")				// x 是整型
x, err := strconv.ParseInt("123", 10, 64)	// 十进制，最长为64位
```

````ParseInt`的第三个参数指定结果必须匹配何种大小的整型```



### 常量

常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。

* 所有常量本质上都属于基本类型：布尔型、字符串或数字。

* 常量声明可以同时指定类型和值，如果没有显示指定类型，则类型根据右边的表达式推断。
* 若同时声明一组常量，除了第一项之外，其他项在等号右侧的表达式都可以省略，这一位置会复用前面一项的表达式及其类型。

#### 常量生成器`iota`

常量声明中，`iota`从0开始取值，逐项加1。

```go
type Weekday int
const (
	Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

#### 无类型常量

从属类型待定的常量共有6种，分别是`无类型布尔`，`无类型浮点数`，`无类型复数`，`无类型字符串`。

* 类似地，`true`和`false`是无类型布尔值，而字符串字面量则是无类型字符串。
* 只有常量才可以是无类型的。



## 复合数据类型

复合数据类型是由基本数据类型以各种方式组合而构成的。

### 数组

数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。

* 相比数组，`slice`很多场合下使用得更多。

* 默认情况下，一个新数组中的元素初始值位元素类型的零值，同时可以用`数组字面量`初始化。

```go
var r [3]int = [3]int{1, 2} // 1, 2, 0
```

* 如果省略号`...`出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。

```go
q := [...]int{1, 2, 3} // [3]int
```

* 数组的长度是数组类型的一部分。
* 数组的长度必须是常量表达式，也就是说，这个表达式的值在程序编译时就可以确定。

* 如果一个数组的元素类型是可比较的，那么这个数组也是可比较的。
* Go把数组和其他的类型都看成值传递，而别的语言中数组是隐式地使用引用传递。

* 使用数组指针是高效的，但由于数组长度不可变的特性，很少使用数组。

### slice

`slice`通常写作`[]T`，其中元素的类型都是`T`，是一种轻量级的数据结构，可以用来访问数组的部分或者全部元素，这个数组称为`slice`的底层数组。

* `slice`有三个属性：指针，长度和容量。

* $$
  slice操作符s[i:j](其中0\leq i \leq j \leq cap(s))
  $$

这个新的slice引用了序列s中从i到j-1索引位置的所有元素，这里的s既可以是数组或者指向数组的指针，也可以是slice。

* 如果`x`是字符串，那么`x[m:n]`返回的是一个字符串；如果`x`是字节`slice`，那么返回的结果是字节`slice`。
* `slice`包含了指向数组元素的指针，所以将一个`slice`传递给函数的时候，可以在函数内部修改底层数组的元素。

* `slice`字面量看上去和数组字面量很像，都是用逗号分隔并用花括号括起来的一个元素序列，但`slice`没有指定长度。

```go
s := []int{0, 1, 2, 3, 4, 5}
```

* 和数组不同，`slice`不能用`=`来测试两个`slice`是否拥有相同的元素。`bytes.Equal()`可以用来比较两个字节`slice`（`[]byte`）。
* `slice`唯一允许的比较操作是和`nil`作比较。值为`nil`的`slice`没有对应的底层数组。

```go
var s []int		// len(s) == 0, s == nil
s = nil			// len(s) == 0, s == nil
s = []int(nil) 	// len(s) == 0, s == nil
s = []int{}		// len(s) == 0, s != nil
```

* 检查一个`slice`是否是空，使用`len(s) == 0`，而不是`s == nil`。

#### `append`函数

内置函数`append`用来将元素追加到`slice`的后面。

```go
var runes []rune
for _, r := range "Hello, 世界"{
    runes = append(runes, r)
}
```

* 调用`append`函数的情况下需要更新`slice`变量。对于任何函数，只要有可能改变`slice`的长度或者容量，亦或者使得`slice`指向不同的底层数组，都需要更新`slice`变量。
* `slice`底层数组的元素是间接引用的，但是`slice`的指针、长度和容量不是。
* 可以同时给`slice`添加多个元素，甚至添加另一个`slice`里的所有元素。

#### `slice`就地修改

`rotate`和`reverse`等可以就地修改`slice`元素的函数。

### map

一个拥有键值对元素的无序集合。在`golang`中，`map`是散列表的引用，`map`的类型是`map[K]V`，其中`k`和`v`是字典的键和值对应的数据类型。

* 内置函数`make`可以用来创建一个`map`：

```go
mapVal := make(map[string]int)
```

* 可以使用内置函数`delete`来从字典中根据键移除一个元素，即使键不在`map`中，操作也是安全的：

```go
delete(mapVal, "value") // 移除元素mapVal["value"]
```

* `map`元素不是一个变量，不可以获取它的地址。

* `map`顺序是随机的，如果需要按照某种顺序来遍历`map`中的元素，必须显示地给键排序。如果键是字符串类型，可以使用`sort`包中的`Strings`函数来进行键的排序。
* 通过一种下标方式访问`map`中的元素输出两个值，第二个值是一个布尔值，用来报告该元素是否存在。

```go
if mapValue, ok := mapValues["val"]; !ok { /* ... */ }
```

* `map`值类型本身可以是复合数据类型。

### 结构体

将零个或者多个任意类型的命名变量组合在一起的聚合数据类型。

(个人思考)：这里的指针跟`c/c++`有所不同，这里的指针可以用`.`直接访问结构体，而`c/c++`需要`->`来访问或者需要`(*ptr)`之后用`.`访问。

* 如果一个结构体的成员变量名称是首字母大写的，那么这个变量是可导出的，这个是`Go`最主要的访问控制机制。
* 命名结构体类型不可以定义一个拥有相同结构体类型的成员变量，但可以定义一个指针类型。

```go
type tree struct {
    value		int
    left, right	*tree
}
```

#### 结构体字面量

结构体类型的值可以通过结构体字面量来设置。

* 有两种格式的结构体字面量：

1. 按照正确的顺序为每个成员量指定一个值。但这样会给开发和阅读代码的人增加负担。
2. 通过指定部分或者全部成员变量的名称和值来初始化结构体变量。如果在这种初始化方式下没有指定，那么该成员变量类型就是默认的该类型零值。

两种初始化方式不可以混合使用。两种方式都绕不过不可导出变量无法在其他包中适用的规则。

* 结构体类型的值可以作为参数传递给函数或者作为函数的返回值。出于效率的考虑，大型的结构体通常都使用结构体指针的方式直接传递给函数或者从函数中返回。在需要修改结构体内容的时候也是必需的，在`Go`按值调用的语言中，调用的函数接收到的是实参的一个副本，并不是实参的引用。

#### 结构体比较

如果结构体的所有成员变量都可以比较，那么这个结构体就是可比较的。

* 可比较的结构体类型都可以作为`map`的键类型。

#### 结构体嵌套和匿名成员

* 可以定义不带名称的结构体成员，只需指定类型即可，这种结构体成员成为匿名成员。这个结构体成员的类型必须是一个命名类型或者指向命名类型的指针。这样能直接访问到需要的变量而不是指定一大串中间变量。但结构体字面量并没有什么快捷方式来初始化结构体。

```(个人理解)匿名成员是不可导出的，但匿名成员它自己的可导出成员仍然是可见的```

### JSON

`golang`通过标准库`encoding/json`，`encoding/xml`，`encoding/asn1`以及其他库对这些格式的编码和解码提供了非常好的支持，这些库都拥有相同的`API`。`JSON`是`JavaScript`值的`Unicode`编码，这些值包括字符串、数字、布尔值、数组和对象。

* `JSON`最基本的类型是数字（以十进制或者科学计数法表示）、布尔值（`true`或`false`）和字符串（用双引号括起来的）。
* `JSON`的数组是一个有序的元素序列，每个元素之间用逗号分隔，两边使用方括号括起来。
* `JSON`的对象是一个从字符串到值的映射，写成`name:value`对的序列，每个元素之间用逗号分隔，两边使用花括号括起来。
* 把Go的数据结构转换为`JSON`成为`marshal`。`marshal`通过`json/Marshal`实现。

```go
data, err := json.Marshal(valueType)
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
```

* `json.MarshalIndent`的变体可以输出整齐格式化过的结果。

```go
data, err := json.MarshalIndent(valueType, "", "    ") // 一个定义每行输出的前缀字符串，另外一个定义缩进的字符串。
```

* `marshal`使用`Go`结构体成员的名称作为`JSON`对象里面字段的名称。只有可导出的成员可以转换为`JSON`字段。

* `marshal`的逆操作将`JSON`字符串解码为`Go`数据结构，这个过程叫做`unmarshal`，这个是由`json.Unmarshal`实现的。通过合理地定义`Go`的数据结构，可以选择将哪部分`JSON`数据解码到结构体对象中，哪些数据可以丢弃。

### 文本和HTML模板

`text/template`和`html/template`两个包可以实现格式和代码彻底分离，这里提供了一种机制，可以将程序变量的值带入到文本或者`HTML`模板中。

* 模板是一个字符串或者文件，它包含一个或者多个两边用双大括号包围的单元`{{...}}`，这称为`操作`。操作可以引发其他行为。
* 每个操作都对应一个表达式，提供输出值，选择结构体成员，调用函数和方法，描述控制逻辑，实例化其他模板等功能。
* 在操作中，符号`|`会将前一个操作的结果当作下一个操作的输入。
* 在操作中，用点号`.`表示当前值的标记。

模板输出结果需要两个步骤。

* 首先需要解析模板并转换为内部的表示方法。
* 然后在指定的输入上面执行。解析模板只需要执行一次。

```go
report, err := template.New("report").Funcs(template.FuncMap{}).Parse(templ)
if err != nil {
    log.Fatal(err)
}
```

* 模板通常是在编译期间就固定下来，因此无法解析模板将是程序程序中的一个严重`bug`。帮助函数`template.Must`提供了一种便捷的错误处理方式，它接受一个模板和错误作为参数，检查错误是否为`nil`（如果不是`nil`，则宕机），然后返回这个模板。

```go
report := template.Must("report").Funcs(template.FuncMap{}).Parse(templ)
```

## 函数

### 函数声明

每个函数声明都包含一个名字、一个形参列表、一个可选的返回列表以及函数体。

```go
func name(parameter-list) (result-list) {
    body
}
```

* 如果一个函数既省略返回列表也没有任何返回值，那么设计这个函数的目的是调用函数之后所带来的附加效果。

* 空白标识符用来强调这个形参在函数中未使用。
* 函数的类型称作函数签名，当两个函数拥有相同的形参列表和返回列表是，认为这两个函数的类型或签名是相同的。
* `golang`没有默认参数值的概念也不能指定实参名。
* 实参都是按值传递，所以函数接收到的是每个实参的副本。
* 如果提供的实参包含引用类型，比如指针、`slice`、`map`、`函数`或者通道，那么当函数使用形参变量时就有可能会间接地修改实参变量。

### 递归

函数可以递归调用，这一位置函数可以直接或间接地调用自己。

* 许多编程语言使用固定长度的函数调用栈；大小在`64KB`到`2MB`之间。
* 递归的深度会受限于固定长度的栈大小，所以当进行深度递归调用时必须谨防栈溢出。
* `golang`语言的实现使用了可变长度的栈，栈的大小会随着使用而增长，可达到`1GB`左右的上限。
